# Beaker GUI MVP Plan - egui Implementation

**Date:** 2025-10-25
**Status:** Implementation Plan
**Target:** Small, complete MVP - detection with bounding boxes

---

## MVP Requirements

- [ ] working detection, including showing bounding boxes
- [ ] tests runnable on your sandbox and CI
- [ ] checked in snapshots, 1 per main view (not too many)
- [ ] macos native menu bar, like docs/demos/egui hello-world setup
- [ ] high dpi resolution, reasonable minimum screen size, good modern aesthetics (hello-world prototypes this)
- [ ] able to be driven from the cli, e.g. we should be able to load the app with an image in place and a view open by passing the right cli flags

---

## Architecture

### Multi-Crate Structure

```
beaker/
├── beaker/           # Existing lib + CLI
├── beaker-gui/       # New GUI crate
│   ├── Cargo.toml    # Independent workspace
│   ├── src/
│   │   ├── main.rs   # App entry, native menu setup
│   │   ├── app.rs    # Main app state & eframe::App impl
│   │   ├── style.rs  # Theme, DPI, styling constants
│   │   ├── views/
│   │   │   ├── mod.rs
│   │   │   └── detection.rs  # Detection view with bboxes
│   │   └── lib.rs    # Re-exports for testing
│   ├── tests/
│   │   ├── gui_tests.rs     # Assert-heavy integration tests
│   │   └── snapshots/       # Checked-in snapshots
│   │       └── detection_view.png
│   └── fonts/        # NotoSans (or system fonts)
```

**Dependencies** (`beaker-gui/Cargo.toml`):
```toml
[package]
name = "beaker-gui"
version = "0.1.0"
edition = "2021"

[workspace]

[dependencies]
eframe = "0.30"
egui = "0.30"
egui_extras = { version = "0.30", features = ["image"] }
image = "0.25"
beaker = { path = "../beaker" }  # Use beaker as library
clap = { version = "4.5", features = ["derive"] }
anyhow = "1.0"

[target.'cfg(target_os = "macos")'.dependencies]
muda = "0.17"  # Native macOS menu bar

[dev-dependencies]
egui_kittest = { version = "0.30", features = ["wgpu", "snapshot"] }
```

**Key principle:** GUI crate depends on `beaker` lib, never vice-versa. Beaker lib remains CLI-focused.

---

## MVP Features

### 1. Detection View

**Core functionality:**
- Load image from CLI flag: `beaker-gui --image path/to/bird.jpg --view detection`
- Run detection using `beaker::detection` API
- Display image with rendered bounding boxes
- Show detection metadata (confidence, class, quality)

**UI Layout:**
```
┌────────────────────────────────────────────┐
│ File  View  Help          [macOS menu bar] │
├────────────────────────────────────────────┤
│  ┌──────────────────┐  ┌─────────────────┐ │
│  │                  │  │ Detections (2)  │ │
│  │   [Image with    │  │ ───────────────  │ │
│  │    bounding      │  │ □ Bird #1       │ │
│  │    boxes]        │  │   Conf: 0.95    │ │
│  │                  │  │   Quality: Good │ │
│  │                  │  │ □ Bird #2       │ │
│  │                  │  │   Conf: 0.87    │ │
│  └──────────────────┘  └─────────────────┘ │
└────────────────────────────────────────────┘
```

**Implementation:**
```rust
// beaker-gui/src/views/detection.rs
use egui::ColorImage;
use beaker::detection::{run_detection_single, DetectionResult};
use image::DynamicImage;

pub struct DetectionView {
    image: Option<DynamicImage>,
    result: Option<DetectionResult>,
    texture: Option<egui::TextureHandle>,
    selected_detection: Option<usize>,
}

impl DetectionView {
    pub fn new(image_path: &str) -> anyhow::Result<Self> {
        let image = image::open(image_path)?;

        // Run detection using beaker lib
        let config = beaker::config::DetectionConfig::single_image(
            image_path.to_string(),
            0.5, // confidence threshold
        );
        let result = beaker::detection::run_detection_single(config)?;

        Ok(Self {
            image: Some(image),
            result: Some(result),
            texture: None,
            selected_detection: None,
        })
    }

    pub fn show(&mut self, ctx: &egui::Context, ui: &mut egui::Ui) {
        egui::SidePanel::right("detections_panel")
            .default_width(250.0)
            .show_inside(ui, |ui| {
                self.show_detections_list(ui);
            });

        egui::CentralPanel::default().show_inside(ui, |ui| {
            self.show_image_with_bboxes(ui, ctx);
        });
    }

    fn show_detections_list(&mut self, ui: &mut egui::Ui) {
        // RUNTIME ASSERT: If we have a result, it must have detections
        if let Some(result) = &self.result {
            assert!(!result.detections.is_empty(),
                    "DetectionView invariant violated: result exists but has no detections");
        }

        // RUNTIME ASSERT: If we have a selected detection, it must be in bounds
        if let Some(selected) = self.selected_detection {
            let det_count = self.result.as_ref().map(|r| r.detections.len()).unwrap_or(0);
            assert!(selected < det_count,
                    "DetectionView invariant violated: selected_detection {} >= detection count {}",
                    selected, det_count);
        }

        ui.heading("Detections");

        if let Some(result) = &self.result {
            ui.label(format!("Found {} objects", result.detections.len()));
            ui.separator();

            for (idx, det) in result.detections.iter().enumerate() {
                let is_selected = self.selected_detection == Some(idx);

                // RUNTIME ASSERT: Confidence must be valid
                assert!(det.detection.confidence >= 0.0 && det.detection.confidence <= 1.0,
                        "Detection confidence out of range: {}", det.detection.confidence);

                // Styled card for each detection
                egui::Frame::none()
                    .fill(if is_selected {
                        egui::Color32::from_rgb(230, 240, 255)
                    } else {
                        egui::Color32::WHITE
                    })
                    .rounding(6.0)
                    .inner_margin(12.0)
                    .stroke(egui::Stroke::new(1.0, egui::Color32::from_gray(200)))
                    .show(ui, |ui| {
                        if ui.selectable_label(false, &det.detection.class_name).clicked() {
                            self.selected_detection = Some(idx);
                        }
                        ui.label(format!("Confidence: {:.2}", det.detection.confidence));
                        if let Some(quality) = &det.detection.quality {
                            ui.label(format!("Blur: {:.2}", quality.blur_score));
                        }
                    });

                ui.add_space(8.0);
            }
        }
    }

    fn show_image_with_bboxes(&mut self, ui: &mut egui::Ui, ctx: &egui::Context) {
        // RUNTIME ASSERT: View must have an image
        assert!(self.image.is_some(), "DetectionView invariant violated: no image loaded");

        if let Some(img) = &self.image {
            // RUNTIME ASSERT: Image dimensions must be non-zero
            assert!(img.width() > 0 && img.height() > 0,
                    "DetectionView invariant violated: image has zero dimensions");

            // Load texture on first render
            if self.texture.is_none() {
                let rendered = self.render_image_with_bboxes(img);

                // RUNTIME ASSERT: Rendered image matches original dimensions
                assert_eq!(rendered.size[0], img.width() as usize);
                assert_eq!(rendered.size[1], img.height() as usize);

                self.texture = Some(ctx.load_texture(
                    "detection_view",
                    rendered,
                    Default::default(),
                ));
            }

            if let Some(texture) = &self.texture {
                // Scale image to fit panel
                let available_size = ui.available_size();
                let image_aspect = texture.size()[0] as f32 / texture.size()[1] as f32;
                let panel_aspect = available_size.x / available_size.y;

                let size = if image_aspect > panel_aspect {
                    egui::vec2(available_size.x, available_size.x / image_aspect)
                } else {
                    egui::vec2(available_size.y * image_aspect, available_size.y)
                };

                ui.centered_and_justified(|ui| {
                    ui.image(texture.id(), size);
                });
            }
        }
    }

    fn render_image_with_bboxes(&self, img: &DynamicImage) -> ColorImage {
        let mut img_rgba = img.to_rgba8();

        if let Some(result) = &self.result {
            for (idx, det) in result.detections.iter().enumerate() {
                let d = &det.detection;

                // RUNTIME ASSERT: Bounding box must be within image bounds
                assert!(d.x1 >= 0.0 && d.x1 < img.width() as f32,
                        "Bbox x1={} out of image width={}", d.x1, img.width());
                assert!(d.y1 >= 0.0 && d.y1 < img.height() as f32,
                        "Bbox y1={} out of image height={}", d.y1, img.height());
                assert!(d.x2 > d.x1 && d.x2 <= img.width() as f32,
                        "Bbox x2={} invalid (x1={}, width={})", d.x2, d.x1, img.width());
                assert!(d.y2 > d.y1 && d.y2 <= img.height() as f32,
                        "Bbox y2={} invalid (y1={}, height={})", d.y2, d.y1, img.height());

                // Color based on selection and class
                let color = if self.selected_detection == Some(idx) {
                    image::Rgba([255u8, 0, 0, 255])  // Red for selected
                } else {
                    image::Rgba([0, 255, 0, 255])    // Green for others
                };

                // Draw bounding box
                imageproc::drawing::draw_hollow_rect_mut(
                    &mut img_rgba,
                    imageproc::rect::Rect::at(d.x1 as i32, d.y1 as i32)
                        .of_size((d.x2 - d.x1) as u32, (d.y2 - d.y1) as u32),
                    color,
                );

                // Draw label
                let label = format!("{} {:.2}", d.class_name, d.confidence);
                // (Use imageproc::drawing::draw_text_mut with font)
            }
        }

        // Convert to egui ColorImage
        let size = [img_rgba.width() as usize, img_rgba.height() as usize];
        let pixels = img_rgba.into_raw();
        ColorImage::from_rgba_unmultiplied(size, &pixels)
    }
}
```

### 2. Main Application

**CLI Integration:**
```rust
// beaker-gui/src/main.rs
use clap::Parser;

#[derive(Parser)]
#[command(name = "beaker-gui")]
struct Args {
    /// Path to image file
    #[arg(long)]
    image: Option<String>,

    /// View to open (detection, etc.)
    #[arg(long, default_value = "detection")]
    view: String,
}

fn main() -> eframe::Result {
    let args = Args::parse();

    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1200.0, 800.0])
            .with_min_inner_size([900.0, 600.0]),
        ..Default::default()
    };

    eframe::run_native(
        "Beaker - Bird Image Analysis",
        options,
        Box::new(move |cc| {
            crate::style::setup_custom_style(&cc.egui_ctx);

            let use_native_menu = cfg!(target_os = "macos")
                && std::env::var("USE_EGUI_MENU").is_err();

            let app = BeakerApp::new(use_native_menu, args.image, args.view);

            #[cfg(target_os = "macos")]
            if use_native_menu {
                let (menu, rx) = create_native_menu();
                menu.init_for_nsapp();
                app.menu = Some(menu);
                app.menu_rx = Some(rx);
            }

            Ok(Box::new(app))
        }),
    )
}
```

**App State:**
```rust
// beaker-gui/src/app.rs
pub struct BeakerApp {
    current_view: Box<dyn View>,
    use_native_menu: bool,
    #[cfg(target_os = "macos")]
    menu: Option<muda::Menu>,
    #[cfg(target_os = "macos")]
    menu_rx: Option<std::sync::mpsc::Receiver<muda::MenuEvent>>,
}

pub trait View {
    fn show(&mut self, ctx: &egui::Context, ui: &mut egui::Ui);
    fn name(&self) -> &str;
}

impl eframe::App for BeakerApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Handle native menu events on macOS
        #[cfg(target_os = "macos")]
        self.poll_menu_events(ctx);

        // Show egui menu if not using native
        if !self.use_native_menu {
            self.show_menu_bar(ctx);
        }

        egui::CentralPanel::default().show(ctx, |ui| {
            self.current_view.show(ctx, ui);
        });
    }
}
```

### 3. Styling

**High-DPI, Modern Aesthetics:**
```rust
// beaker-gui/src/style.rs
pub fn setup_custom_style(ctx: &egui::Context) {
    // High DPI for retina displays
    ctx.set_pixels_per_point(2.0);

    let mut style = (*ctx.style()).clone();

    // Professional spacing
    style.spacing.item_spacing = egui::vec2(16.0, 10.0);
    style.spacing.button_padding = egui::vec2(16.0, 8.0);
    style.spacing.window_margin = egui::Margin::same(20.0);

    // Rounded corners
    let rounding = egui::Rounding::same(8.0);
    style.visuals.window_rounding = rounding;
    style.visuals.widgets.noninteractive.rounding = egui::Rounding::same(6.0);
    style.visuals.widgets.inactive.rounding = egui::Rounding::same(6.0);
    style.visuals.widgets.hovered.rounding = egui::Rounding::same(6.0);
    style.visuals.widgets.active.rounding = egui::Rounding::same(6.0);

    // Clean color scheme (light mode, scientific tool aesthetic)
    style.visuals.window_fill = egui::Color32::from_gray(248);
    style.visuals.panel_fill = egui::Color32::from_gray(250);
    style.visuals.extreme_bg_color = egui::Color32::WHITE;

    // Accent colors (blue for science/analysis)
    style.visuals.selection.bg_fill = egui::Color32::from_rgb(70, 130, 200);
    style.visuals.widgets.hovered.bg_stroke =
        egui::Stroke::new(2.0, egui::Color32::from_rgb(100, 150, 220));

    // Subtle shadows
    style.visuals.window_shadow = egui::epaint::Shadow {
        offset: egui::vec2(0.0, 4.0),
        blur: 12.0,
        spread: 0.0,
        color: egui::Color32::from_black_alpha(30),
    };

    ctx.set_style(style);
}

// Design constants
pub const MIN_WINDOW_WIDTH: f32 = 900.0;
pub const MIN_WINDOW_HEIGHT: f32 = 600.0;
pub const DETECTION_PANEL_WIDTH: f32 = 250.0;
```

---

## Testing Strategy

### Two-Layer Validation Approach

**Strategy:** Runtime asserts + integration tests = self-validating GUI

1. **Runtime Asserts (in GUI code):** Strategic `assert!` calls in the actual view code validate invariants during normal operation
2. **Integration Tests:** Exercise GUI views and verify they don't panic

**Outcome:** Run `beaker-gui --image bird.jpg --view detection`, wait 10s with no panic → all invariants hold.

### Runtime Asserts in GUI Code

**Philosophy:** GUI code includes assertions that validate invariants. These run during normal operation AND during tests.

**Example runtime asserts (shown in implementation above):**
- Detection result must not be empty if it exists
- Selected detection must be in bounds
- Confidence scores must be in [0.0, 1.0]
- Bounding boxes must be within image dimensions
- Image dimensions must be non-zero
- Rendered texture must match original image size

### Integration Tests

**Philosophy:** Tests exercise GUI views and verify runtime asserts don't panic.

```rust
// beaker-gui/tests/gui_tests.rs
use egui_kittest::Harness;
use beaker_gui::{DetectionView, style};

#[test]
fn test_detection_view_full_lifecycle() {
    // This test exercises the full view lifecycle
    // If runtime asserts pass, all invariants are valid
    let test_image = "tests/fixtures/test_bird.jpg";
    let mut view = DetectionView::new(test_image)
        .expect("Failed to create detection view");

    // Render the view (will trigger all runtime asserts in show_detections_list,
    // show_image_with_bboxes, and render_image_with_bboxes)
    let mut harness = Harness::new_ui(|ui| {
        style::setup_custom_style(ui.ctx());
        view.show(ui.ctx(), ui);
    });

    harness.run();
    harness.wgpu_snapshot("detection_view");

    // If we got here, all runtime asserts passed
}

#[test]
fn test_detection_selection_invariants() {
    // Test that selecting detections maintains invariants
    let test_image = "tests/fixtures/test_bird.jpg";
    let mut view = DetectionView::new(test_image).unwrap();

    // Select each detection in turn
    let det_count = view.result.as_ref().unwrap().detections.len();
    for idx in 0..det_count {
        view.selected_detection = Some(idx);

        // Render with selection (runtime asserts validate selection is in bounds)
        let mut harness = Harness::new_ui(|ui| {
            view.show(ui.ctx(), ui);
        });
        harness.run();
    }

    // Clear selection
    view.selected_detection = None;
    let mut harness = Harness::new_ui(|ui| {
        view.show(ui.ctx(), ui);
    });
    harness.run();
}

#[test]
fn test_multiple_views_in_sequence() {
    // Test creating and destroying views (validates cleanup)
    let test_images = [
        "tests/fixtures/test_bird.jpg",
        "tests/fixtures/test_bird_2.jpg",
    ];

    for img_path in &test_images {
        let mut view = DetectionView::new(img_path).unwrap();

        let mut harness = Harness::new_ui(|ui| {
            view.show(ui.ctx(), ui);
        });
        harness.run();

        // View drops here - runtime asserts validate state throughout
    }
}
```

**Key principle:** Tests don't duplicate runtime asserts. Tests exercise code paths; runtime asserts validate invariants.

### Snapshot Testing

**Setup:**
```bash
# Generate snapshots
cd beaker-gui
UPDATE_SNAPSHOTS=1 cargo test

# Snapshots stored in tests/snapshots/
# - detection_view.png (1 main view snapshot only)
```

**CI Integration:**
```yaml
# .github/workflows/beaker-gui-ci.yml
name: Beaker GUI CI

on:
  push:
    paths: ['beaker-gui/**', '.github/workflows/beaker-gui-ci.yml']
  pull_request:
    paths: ['beaker-gui/**']

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable

      - name: Install lavapipe (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y mesa-vulkan-drivers libvulkan1

      - name: Build
        working-directory: beaker-gui
        run: cargo build --release

      - name: Test with snapshots
        working-directory: beaker-gui
        run: UPDATE_SNAPSHOTS=1 cargo test --verbose

      - name: Upload snapshots
        uses: actions/upload-artifact@v4
        with:
          name: gui-snapshots-${{ matrix.os }}
          path: beaker-gui/tests/snapshots/
```

---

## Extension Framework

**Adding new features (cookie-cutter approach):**

1. **New algorithm in beaker lib** → 2. **New view in GUI**

Example: Adding segmentation view:
```rust
// beaker-gui/src/views/segmentation.rs
pub struct SegmentationView {
    image: Option<DynamicImage>,
    masks: Vec<Mask>,  // From beaker::segmentation
}

impl View for SegmentationView {
    fn show(&mut self, ctx: &egui::Context, ui: &mut egui::Ui) {
        // Same pattern as DetectionView
        // - Side panel with masks list
        // - Central panel with image + overlay
    }

    fn name(&self) -> &str { "Segmentation" }
}

// Add to CLI args:
// beaker-gui --image bird.jpg --view segmentation
```

**Key pattern:** Each view owns its data and rendering. Views implement `View` trait. App switches views based on CLI flags.

---

## Implementation Checklist

**MVP Deliverables:**
- [ ] `beaker-gui/` crate with workspace setup
- [ ] Detection view with bounding box rendering
- [ ] CLI flags: `--image`, `--view`
- [ ] macOS native menu bar via `muda`
- [ ] High-DPI styling (2.0 pixels_per_point)
- [ ] Assert-heavy tests (3+ tests covering rendering, interaction, data)
- [ ] 1 snapshot: `detection_view.png`
- [ ] CI workflow for Linux + macOS
- [ ] README with build/run instructions

**Anti-patterns to avoid:**
- ❌ No placeholder views ("Coming soon...")
- ❌ No disabled buttons with TODO comments
- ❌ No mock data - use real beaker lib
- ❌ No complex state management - keep it simple

**Time estimate:** ~2-3 days for complete MVP with tests and CI.
