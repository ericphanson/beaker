# Beaker GUI MVP Plan - egui Implementation

**Date:** 2025-10-25
**Status:** Implementation Plan
**Target:** Small, complete MVP - detection with bounding boxes

---

## Architecture

### Multi-Crate Structure

```
beaker/
├── beaker/           # Existing lib + CLI
├── beaker-gui/       # New GUI crate
│   ├── Cargo.toml    # Independent workspace
│   ├── src/
│   │   ├── main.rs   # App entry, native menu setup
│   │   ├── app.rs    # Main app state & eframe::App impl
│   │   ├── style.rs  # Theme, DPI, styling constants
│   │   ├── views/
│   │   │   ├── mod.rs
│   │   │   └── detection.rs  # Detection view with bboxes
│   │   └── lib.rs    # Re-exports for testing
│   ├── tests/
│   │   ├── gui_tests.rs     # Assert-heavy integration tests
│   │   └── snapshots/       # Checked-in snapshots
│   │       └── detection_view.png
│   └── fonts/        # NotoSans (or system fonts)
```

**Dependencies** (`beaker-gui/Cargo.toml`):
```toml
[package]
name = "beaker-gui"
version = "0.1.0"
edition = "2021"

[workspace]

[dependencies]
eframe = "0.30"
egui = "0.30"
egui_extras = { version = "0.30", features = ["image"] }
image = "0.25"
beaker = { path = "../beaker" }  # Use beaker as library
clap = { version = "4.5", features = ["derive"] }
anyhow = "1.0"

[target.'cfg(target_os = "macos")'.dependencies]
muda = "0.17"  # Native macOS menu bar

[dev-dependencies]
egui_kittest = { version = "0.30", features = ["wgpu", "snapshot"] }
```

**Key principle:** GUI crate depends on `beaker` lib, never vice-versa. Beaker lib remains CLI-focused.

---

## MVP Features

### 1. Detection View

**Core functionality:**
- Load image from CLI flag: `beaker-gui --image path/to/bird.jpg --view detection`
- Run detection using `beaker::detection` API
- Display image with rendered bounding boxes
- Show detection metadata (confidence, class, quality)

**UI Layout:**
```
┌────────────────────────────────────────────┐
│ File  View  Help          [macOS menu bar] │
├────────────────────────────────────────────┤
│  ┌──────────────────┐  ┌─────────────────┐ │
│  │                  │  │ Detections (2)  │ │
│  │   [Image with    │  │ ───────────────  │ │
│  │    bounding      │  │ □ Bird #1       │ │
│  │    boxes]        │  │   Conf: 0.95    │ │
│  │                  │  │   Quality: Good │ │
│  │                  │  │ □ Bird #2       │ │
│  │                  │  │   Conf: 0.87    │ │
│  └──────────────────┘  └─────────────────┘ │
└────────────────────────────────────────────┘
```

**Implementation:**
```rust
// beaker-gui/src/views/detection.rs
use egui::ColorImage;
use beaker::detection::{run_detection_single, DetectionResult};
use image::DynamicImage;

pub struct DetectionView {
    image: Option<DynamicImage>,
    result: Option<DetectionResult>,
    texture: Option<egui::TextureHandle>,
    selected_detection: Option<usize>,
}

impl DetectionView {
    pub fn new(image_path: &str) -> anyhow::Result<Self> {
        let image = image::open(image_path)?;

        // Run detection using beaker lib
        let config = beaker::config::DetectionConfig::single_image(
            image_path.to_string(),
            0.5, // confidence threshold
        );
        let result = beaker::detection::run_detection_single(config)?;

        Ok(Self {
            image: Some(image),
            result: Some(result),
            texture: None,
            selected_detection: None,
        })
    }

    pub fn show(&mut self, ctx: &egui::Context, ui: &mut egui::Ui) {
        egui::SidePanel::right("detections_panel")
            .default_width(250.0)
            .show_inside(ui, |ui| {
                self.show_detections_list(ui);
            });

        egui::CentralPanel::default().show_inside(ui, |ui| {
            self.show_image_with_bboxes(ui, ctx);
        });
    }

    fn show_detections_list(&mut self, ui: &mut egui::Ui) {
        ui.heading("Detections");

        if let Some(result) = &self.result {
            ui.label(format!("Found {} objects", result.detections.len()));
            ui.separator();

            for (idx, det) in result.detections.iter().enumerate() {
                let is_selected = self.selected_detection == Some(idx);

                // Styled card for each detection
                egui::Frame::none()
                    .fill(if is_selected {
                        egui::Color32::from_rgb(230, 240, 255)
                    } else {
                        egui::Color32::WHITE
                    })
                    .rounding(6.0)
                    .inner_margin(12.0)
                    .stroke(egui::Stroke::new(1.0, egui::Color32::from_gray(200)))
                    .show(ui, |ui| {
                        if ui.selectable_label(false, &det.detection.class_name).clicked() {
                            self.selected_detection = Some(idx);
                        }
                        ui.label(format!("Confidence: {:.2}", det.detection.confidence));
                        if let Some(quality) = &det.detection.quality {
                            ui.label(format!("Blur: {:.2}", quality.blur_score));
                        }
                    });

                ui.add_space(8.0);
            }
        }

        // Assert: detections must be non-empty if we got this far
        assert!(self.result.as_ref().map(|r| !r.detections.is_empty()).unwrap_or(true),
                "Detection view should not exist with empty detections");
    }

    fn show_image_with_bboxes(&mut self, ui: &mut egui::Ui, ctx: &egui::Context) {
        if let Some(img) = &self.image {
            // Load texture on first render
            if self.texture.is_none() {
                let rendered = self.render_image_with_bboxes(img);
                self.texture = Some(ctx.load_texture(
                    "detection_view",
                    rendered,
                    Default::default(),
                ));
            }

            if let Some(texture) = &self.texture {
                // Scale image to fit panel
                let available_size = ui.available_size();
                let image_aspect = texture.size()[0] as f32 / texture.size()[1] as f32;
                let panel_aspect = available_size.x / available_size.y;

                let size = if image_aspect > panel_aspect {
                    egui::vec2(available_size.x, available_size.x / image_aspect)
                } else {
                    egui::vec2(available_size.y * image_aspect, available_size.y)
                };

                ui.centered_and_justified(|ui| {
                    ui.image(texture.id(), size);
                });
            }
        }
    }

    fn render_image_with_bboxes(&self, img: &DynamicImage) -> ColorImage {
        let mut img_rgba = img.to_rgba8();

        if let Some(result) = &self.result {
            for (idx, det) in result.detections.iter().enumerate() {
                let d = &det.detection;

                // Color based on selection and class
                let color = if self.selected_detection == Some(idx) {
                    image::Rgba([255u8, 0, 0, 255])  // Red for selected
                } else {
                    image::Rgba([0, 255, 0, 255])    // Green for others
                };

                // Draw bounding box
                imageproc::drawing::draw_hollow_rect_mut(
                    &mut img_rgba,
                    imageproc::rect::Rect::at(d.x1 as i32, d.y1 as i32)
                        .of_size((d.x2 - d.x1) as u32, (d.y2 - d.y1) as u32),
                    color,
                );

                // Draw label
                let label = format!("{} {:.2}", d.class_name, d.confidence);
                // (Use imageproc::drawing::draw_text_mut with font)
            }
        }

        // Convert to egui ColorImage
        let size = [img_rgba.width() as usize, img_rgba.height() as usize];
        let pixels = img_rgba.into_raw();
        ColorImage::from_rgba_unmultiplied(size, &pixels)
    }
}
```

### 2. Main Application

**CLI Integration:**
```rust
// beaker-gui/src/main.rs
use clap::Parser;

#[derive(Parser)]
#[command(name = "beaker-gui")]
struct Args {
    /// Path to image file
    #[arg(long)]
    image: Option<String>,

    /// View to open (detection, etc.)
    #[arg(long, default_value = "detection")]
    view: String,
}

fn main() -> eframe::Result {
    let args = Args::parse();

    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1200.0, 800.0])
            .with_min_inner_size([900.0, 600.0]),
        ..Default::default()
    };

    eframe::run_native(
        "Beaker - Bird Image Analysis",
        options,
        Box::new(move |cc| {
            crate::style::setup_custom_style(&cc.egui_ctx);

            let use_native_menu = cfg!(target_os = "macos")
                && std::env::var("USE_EGUI_MENU").is_err();

            let app = BeakerApp::new(use_native_menu, args.image, args.view);

            #[cfg(target_os = "macos")]
            if use_native_menu {
                let (menu, rx) = create_native_menu();
                menu.init_for_nsapp();
                app.menu = Some(menu);
                app.menu_rx = Some(rx);
            }

            Ok(Box::new(app))
        }),
    )
}
```

**App State:**
```rust
// beaker-gui/src/app.rs
pub struct BeakerApp {
    current_view: Box<dyn View>,
    use_native_menu: bool,
    #[cfg(target_os = "macos")]
    menu: Option<muda::Menu>,
    #[cfg(target_os = "macos")]
    menu_rx: Option<std::sync::mpsc::Receiver<muda::MenuEvent>>,
}

pub trait View {
    fn show(&mut self, ctx: &egui::Context, ui: &mut egui::Ui);
    fn name(&self) -> &str;
}

impl eframe::App for BeakerApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Handle native menu events on macOS
        #[cfg(target_os = "macos")]
        self.poll_menu_events(ctx);

        // Show egui menu if not using native
        if !self.use_native_menu {
            self.show_menu_bar(ctx);
        }

        egui::CentralPanel::default().show(ctx, |ui| {
            self.current_view.show(ctx, ui);
        });
    }
}
```

### 3. Styling

**High-DPI, Modern Aesthetics:**
```rust
// beaker-gui/src/style.rs
pub fn setup_custom_style(ctx: &egui::Context) {
    // High DPI for retina displays
    ctx.set_pixels_per_point(2.0);

    let mut style = (*ctx.style()).clone();

    // Professional spacing
    style.spacing.item_spacing = egui::vec2(16.0, 10.0);
    style.spacing.button_padding = egui::vec2(16.0, 8.0);
    style.spacing.window_margin = egui::Margin::same(20.0);

    // Rounded corners
    let rounding = egui::Rounding::same(8.0);
    style.visuals.window_rounding = rounding;
    style.visuals.widgets.noninteractive.rounding = egui::Rounding::same(6.0);
    style.visuals.widgets.inactive.rounding = egui::Rounding::same(6.0);
    style.visuals.widgets.hovered.rounding = egui::Rounding::same(6.0);
    style.visuals.widgets.active.rounding = egui::Rounding::same(6.0);

    // Clean color scheme (light mode, scientific tool aesthetic)
    style.visuals.window_fill = egui::Color32::from_gray(248);
    style.visuals.panel_fill = egui::Color32::from_gray(250);
    style.visuals.extreme_bg_color = egui::Color32::WHITE;

    // Accent colors (blue for science/analysis)
    style.visuals.selection.bg_fill = egui::Color32::from_rgb(70, 130, 200);
    style.visuals.widgets.hovered.bg_stroke =
        egui::Stroke::new(2.0, egui::Color32::from_rgb(100, 150, 220));

    // Subtle shadows
    style.visuals.window_shadow = egui::epaint::Shadow {
        offset: egui::vec2(0.0, 4.0),
        blur: 12.0,
        spread: 0.0,
        color: egui::Color32::from_black_alpha(30),
    };

    ctx.set_style(style);
}

// Design constants
pub const MIN_WINDOW_WIDTH: f32 = 900.0;
pub const MIN_WINDOW_HEIGHT: f32 = 600.0;
pub const DETECTION_PANEL_WIDTH: f32 = 250.0;
```

---

## Testing Strategy

### Assert-Heavy Tests

**Philosophy:** If tests run without panicking, the UI works. Use strategic asserts to validate invariants.

```rust
// beaker-gui/tests/gui_tests.rs
use egui_kittest::Harness;
use beaker_gui::{DetectionView, style};

#[test]
fn test_detection_view_renders() {
    // Setup: create view with test image
    let test_image = "tests/fixtures/test_bird.jpg";
    let view = DetectionView::new(test_image)
        .expect("Failed to create detection view");

    // Assert: view must have loaded image
    assert!(view.image.is_some(), "Image must be loaded");
    assert!(view.result.is_some(), "Detection must have run");

    // Assert: must have found detections (test image has birds)
    let result = view.result.as_ref().unwrap();
    assert!(!result.detections.is_empty(),
            "Test image must produce detections");

    // Test UI rendering
    let mut harness = Harness::new_ui(|ui| {
        style::setup_custom_style(ui.ctx());
        view.show(ui.ctx(), ui);
    });

    harness.run();

    // Generate snapshot
    harness.wgpu_snapshot("detection_view");

    // Assert: UI must have rendered without panic
    // (implicit - test completes successfully)
}

#[test]
fn test_detection_selection() {
    let test_image = "tests/fixtures/test_bird.jpg";
    let mut view = DetectionView::new(test_image).unwrap();

    // Assert: initially no selection
    assert!(view.selected_detection.is_none());

    // Simulate selection
    view.selected_detection = Some(0);
    assert_eq!(view.selected_detection, Some(0));

    // Test that rendering with selection doesn't panic
    let mut harness = Harness::new_ui(|ui| {
        view.show(ui.ctx(), ui);
    });
    harness.run();
}

#[test]
fn test_bounding_box_rendering() {
    let test_image = "tests/fixtures/test_bird.jpg";
    let view = DetectionView::new(test_image).unwrap();

    let img = view.image.as_ref().unwrap();
    let rendered = view.render_image_with_bboxes(img);

    // Assert: rendered image has same dimensions
    assert_eq!(rendered.size[0], img.width() as usize);
    assert_eq!(rendered.size[1], img.height() as usize);

    // Assert: pixels are not all the same (bboxes were drawn)
    let pixels = &rendered.pixels;
    assert!(pixels.windows(2).any(|w| w[0] != w[1]),
            "Image must have variation (bboxes drawn)");
}
```

### Snapshot Testing

**Setup:**
```bash
# Generate snapshots
cd beaker-gui
UPDATE_SNAPSHOTS=1 cargo test

# Snapshots stored in tests/snapshots/
# - detection_view.png (1 main view snapshot only)
```

**CI Integration:**
```yaml
# .github/workflows/beaker-gui-ci.yml
name: Beaker GUI CI

on:
  push:
    paths: ['beaker-gui/**', '.github/workflows/beaker-gui-ci.yml']
  pull_request:
    paths: ['beaker-gui/**']

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable

      - name: Install lavapipe (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y mesa-vulkan-drivers libvulkan1

      - name: Build
        working-directory: beaker-gui
        run: cargo build --release

      - name: Test with snapshots
        working-directory: beaker-gui
        run: UPDATE_SNAPSHOTS=1 cargo test --verbose

      - name: Upload snapshots
        uses: actions/upload-artifact@v4
        with:
          name: gui-snapshots-${{ matrix.os }}
          path: beaker-gui/tests/snapshots/
```

---

## Extension Framework

**Adding new features (cookie-cutter approach):**

1. **New algorithm in beaker lib** → 2. **New view in GUI**

Example: Adding segmentation view:
```rust
// beaker-gui/src/views/segmentation.rs
pub struct SegmentationView {
    image: Option<DynamicImage>,
    masks: Vec<Mask>,  // From beaker::segmentation
}

impl View for SegmentationView {
    fn show(&mut self, ctx: &egui::Context, ui: &mut egui::Ui) {
        // Same pattern as DetectionView
        // - Side panel with masks list
        // - Central panel with image + overlay
    }

    fn name(&self) -> &str { "Segmentation" }
}

// Add to CLI args:
// beaker-gui --image bird.jpg --view segmentation
```

**Key pattern:** Each view owns its data and rendering. Views implement `View` trait. App switches views based on CLI flags.

---

## Implementation Checklist

**MVP Deliverables:**
- [ ] `beaker-gui/` crate with workspace setup
- [ ] Detection view with bounding box rendering
- [ ] CLI flags: `--image`, `--view`
- [ ] macOS native menu bar via `muda`
- [ ] High-DPI styling (2.0 pixels_per_point)
- [ ] Assert-heavy tests (3+ tests covering rendering, interaction, data)
- [ ] 1 snapshot: `detection_view.png`
- [ ] CI workflow for Linux + macOS
- [ ] README with build/run instructions

**Anti-patterns to avoid:**
- ❌ No placeholder views ("Coming soon...")
- ❌ No disabled buttons with TODO comments
- ❌ No mock data - use real beaker lib
- ❌ No complex state management - keep it simple

**Time estimate:** ~2-3 days for complete MVP with tests and CI.
